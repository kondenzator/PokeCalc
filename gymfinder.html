<html>
<head>

<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.13/css/jquery.dataTables.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/fixedcolumns/3.2.2/css/fixedColumns.dataTables.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/select/1.2.1/css/select.dataTables.min.css"/>

<script type="text/javascript" src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script type="text/javascript" src="https://cdn.datatables.net/1.10.13/js/jquery.dataTables.min.js"></script>
<script type="text/javascript" src="https://cdn.datatables.net/fixedcolumns/3.2.2/js/dataTables.fixedColumns.min.js"></script>
<script type="text/javascript" src="https://cdn.datatables.net/select/1.2.1/js/dataTables.select.min.js"></script>
<script type="text/javascript" src="gymData.js"></script>

<script type="text/javascript">
/*
Finding the closest 10 gyms in Budapest


database sources:
https://www.reddit.com/r/pokemongodev/comments/4xp2n7/can_you_export_pokestops_and_gym_locations_from/
https://www.reddit.com/r/pokemongodev/comments/4z74nx/does_anyone_have_a_downloadable_database_for_all/?sort=new
https://www.reddit.com/r/pokemongodev/comments/5grpfd/how_to_get_list_of_gym_coordinates_for_my_city/
It seems that the only usable source is www.pokemongomap.info:
1. collect XmlHttpRequests --> JSON database
2. preprocess: throw unneeded elements, give understandable name for the attributes
3. base64-decode the coordinates

combinatorical number systems:
https://en.wikipedia.org/wiki/Combinatorial_number_system
http://mathoverflow.net/questions/29942/order-of-a-combination-when-mapping-them-to-whole-numbers
https://computationalcombinatorics.wordpress.com/2012/09/10/ranking-and-unranking-of-combinations-and-permutations/
*/

/*eslint-env jquery */
/*globals restart */

//------------------------------ CONSTANTS ------------------------------
const global = window;
const subAreaMax = 50;
const numOfGyms = 10;
const maxGyms = 450;
const pointSizePx = 3;    //in px, later scaled
var pointSize = 0;
const binSearchStepThreshold = 15;
// direction rule showing the subarea generation directions
//[a, b, c] --> [a, b]=relative start point (corner of the main rectangle), c=primary subarea generation direction
const dirRule = [ 0, 1, 1 ];
const subAreaType = 2; //subarea shape type. 0 = square, 1 = circle, 2 = rectangle
const visualize = true;

//subarea counts per configuration
//            square circle rectangle
//[ 0, 1, 0 ] 27     27     28
//[ 0, 1, 1 ] 31     28     28
//[ 1, 1, 0 ] 28     26     28
//[ 1, 1, 1 ] 31     27     29
//[ 1, 0, 0 ] 30     25     28
//[ 1, 0, 1 ] 29     26     28
//[ 0, 0, 0 ] 30     25     30
//[ 0, 1, 1 ] 31     28     28

//------------------------------ GLOBAL VARIABLES ------------------------------
var data = new Array();
var f = new Array();
//global variables for subarea computation
var minX, maxX, minY, maxY;
var c = new Array(); //this will hold the canvas 2D contextes
var subAreas = new Array(); //result of the computation: shapes which contain about 50 gyms per each
var point = new Array(); //a point selected from shape corners and intersections to draw a new shape around it
var lowerSize = 0;       //lower shape size for binary search algorithm
var higherSize = 0;      //higher shape size for binary search algorithm
var size = 0;            //actual shape size for binary search algorithm

//------------------------------ HELPER FUNCS ------------------------------
function fact(n)
{
    var res=1;
    for(var i=2; i<=n; i++)
    {
        res *= i;
    }
    return res;
}

function binom(n, k)
{
    var ret;
    if(n >= k)
    {
        //lookup table is used instead of the fact() function
        ret = f[n]/(f[k]*f[n-k]);
    }
    else
    {
        ret = 0;
    }
    return ret;
}

function drawX(x, y, canvas)
{
    if(x.constructor === Array)
    {
        canvas = y;
        y = x[1];
        x = x[0];
    }
    else
    {
        // do nothing
    }

    //draw an 'X' on the point
    canvas.beginPath();
    canvas.moveTo(x-pointSize, y-pointSize);
    canvas.lineTo(x+pointSize, y+pointSize);
    canvas.moveTo(x-pointSize, y+pointSize);
    canvas.lineTo(x+pointSize, y-pointSize);
    canvas.stroke();
}
function drawO(x, y, canvas)
{
    if(x.constructor === Array)
    {
        canvas = y;
        y = x[1];
        x = x[0];
    }
    else
    {
        // do nothing
    }

    //draw an 'O' on the point
    canvas.beginPath();
    canvas.arc(x, y, pointSize, 0, 2*Math.PI);
    canvas.stroke();
}
//first horizontal line x, y1, y2, then vertical line x1, x2, y
//this function doesn't support arrays as coordinates
function linesIntersect(h_x1, h_x2, h_y, v_x, v_y1, v_y2)
{
    var ret;

    //if an end point of one line is on the other line, it doesn't count
    if( (h_x1 < v_x) && (v_x < h_x2) && (v_y1 < h_y) && (h_y < v_y2) )
    {
        ret = [v_x, h_y];
    }
    else
    {
        //return absolutely nothing
    }

    return ret;
}
//the function checks the (base->p) vector if it follows the subarea generation direction rule
function followsDirRule(base, p)
{
    var ret;
    //calculate primary and secondary coordinates
    var pr = dirRule[2];
    var se = 1 - pr;
    //calculate directions
    var prDir = 1 - 2*dirRule[pr];
    var seDir = 1 - 2*dirRule[se];

    //vector doesn't follow primary direction of rule (it should be checked together with secondary direction)
    if(0 < seDir * (base[1-pr] - p[1-pr]))
    {
        ret = false;
    }
    //vector follows primary direction of rule
    else if(0 > seDir * (base[1-pr] - p[1-pr]))
    {
        ret = true;
    }
    //primary direction cannot be checked, check secondary
    else
    {
        //vector doesn't follow secondary direction of rule (it should be checked together with primary direction)
        if(0 < prDir * (base[1-se] - p[1-se]))
        {
            ret = false;
        }
        //vector follows secondary direction of rule
        //if it still cannot be checked (because vector is null) it is considered as following the rule
        else
        {
            ret = true;
        }
    }
    return ret;
}
//push only the thing to push exists
Array.prototype.push2 = function(a)
{
    if( (null !== a) && (undefined !== a) )
    {
        this.push(a);
    }
    else
    {
        //do nothing
    }
};

//------------------------------ CLASSES ------------------------------
class Rectangle
{
    //parameters are: X and Y coordinates of the lower left corner, then X and Y for the higher right corner
    constructor(x1, y1, x2, y2, canvas)
    {
        //handle other coordinate-representation
        if( (x1.constructor === Array) && (y1.constructor === Array) )
        {
            y2 = y1[1];
            x2 = y1[0];
            y1 = x1[1];
            x1 = x1[0];
        }
        else
        {
            //do nothing
        }
        //check if the right corner coordinates were given
        if(x1 > x2)
        {
            this.x1 = x2;
            this.x2 = x1;
        }
        else
        {
            this.x1 = x1;
            this.x2 = x2;
        }

        if(y1 > y2)
        {
            this.y1 = y2;
            this.y2 = y1;
        }
        else
        {
            this.y1 = y1;
            this.y2 = y2;
        }
        
        this.gyms = new Array();

        //draw the rectangle on the referenced canvas (layer)
        if(visualize)
        {
            this.draw(canvas);
        }
    };
    draw(canvas)
    {
        //(re)draw the rectangle on the referenced canvas (layer)
        canvas.strokeRect(this.x1,this.y1,this.x2-this.x1,this.y2-this.y1);
    };
    //check is a point is inside of the rectangle
    //a point near/on the edge is handled differently in different situations, this function should solve all needs
    //the solution is to return smallest distance from the rectangle edges. Positive number means that the point is inside the rectangle, negative means that it's outside and 0 means that it is on an edge.
    //it can check also lines (when only x or y coordinate is passed)
    //equation should be never checked because it's working with floating point numbers
    pointIsInside(x, y)
    {
        var disty = Infinity;
        var distx = Infinity;
        var dist1;
        var dist2;
        var ret;

        //handle other coordinate-representation
        if((null !== x) && (x.constructor === Array))
        {
            y = x[1];
            x = x[0];
        }

        if(null !== y)
        {
            dist1 = y - this.y1;
            dist2 = this.y2 - y;
            if(Math.abs(dist1) < Math.abs(dist2))
            {
                disty = dist1;
            }
            else
            {
                disty = dist2;
            }
        }

        if(null !== x)
        {
            dist1 = x - this.x1;
            dist2 = this.x2 - x;
            if(Math.abs(dist1) < Math.abs(dist2))
            {
                distx = dist1;
            }
            else
            {
                distx = dist2;
            }
        }

        if(distx < disty)
        {
            ret = distx;
        }
        else
        {
            ret = disty;
        }

        return ret;
    };
    getCorners()
    {
        var corners = new Array();
        //corner order is important: start with smaller x and smaller y and make a round counter-clockwise
        //lower left, lower right, upper right, upper left
        corners.push([this.x1, this.y1]);
        corners.push([this.x2, this.y1]);
        corners.push([this.x2, this.y2]);
        corners.push([this.x1, this.y2]);
        return corners;
    };
    //find intersect points of two shapes
    getIntersect(shape)
    {
        var res = new Array();

        if(shape instanceof Rectangle)
        {
            //corner of one rectangle being on edge/corner of other rectangle is not considered as an intersection, because corners of both rectangles are
            //  considered separately by the user algorithm

            //check all horizontal-vertical line pairs for intersections
            res.push2(linesIntersect(this.x1, this.x2, this.y1, shape.x1, shape.y1, shape.y2));
            res.push2(linesIntersect(this.x1, this.x2, this.y1, shape.x2, shape.y1, shape.y2));
            res.push2(linesIntersect(this.x1, this.x2, this.y2, shape.x1, shape.y1, shape.y2));
            res.push2(linesIntersect(this.x1, this.x2, this.y2, shape.x2, shape.y1, shape.y2));
            res.push2(linesIntersect(shape.x1, shape.x2, shape.y1, this.x1, this.y1, this.y2));
            res.push2(linesIntersect(shape.x1, shape.x2, shape.y1, this.x2, this.y1, this.y2));
            res.push2(linesIntersect(shape.x1, shape.x2, shape.y2, this.x1, this.y1, this.y2));
            res.push2(linesIntersect(shape.x1, shape.x2, shape.y2, this.x2, this.y1, this.y2));
        }
        else if(shape instanceof Circle) //eslint-disable-line no-use-before-define
        {
            //use the reversed implementation
            res = res.concat(shape.getIntersect(this));
        }
        else
        {
            //do nothing
        }

        return res;
    }
}
class Circle
{
    //parameters are: X and Y coordinates of the lower left corner, then X and Y for the higher right corner
    constructor(x, y, r, canvas)
    {
        //handle other coordinate-representation
        if(x.constructor === Array)
        {
            canvas = r;
            r = y;
            y = x[1];
            x = x[0];
        }
        else
        {
            //do nothing
        }
        this.x=x;
        this.y=y;
        this.r=r;
        
        this.gyms = new Array();

        //draw the rectangle on the referenced canvas (layer)
        if(visualize)
        {
            this.draw(canvas);
        }
    };
    draw(canvas)
    {
        //(re)draw the circle on the referenced canvas (layer)
        canvas.beginPath();
        canvas.arc(this.x, this.y, this.r, 0, 2*Math.PI);
        canvas.stroke();
    };
    //check is a point is inside of the circle
    //a point near/on the edge is handled differently in different situations, this function should solve all needs
    //the solution is to return smallest distance from the edge. Positive number means that the point is inside the circle, negative means that it's outside and 0 means that it is on an edge.
    //equation should be never checked because it's working with floating point numbers
    pointIsInside(x, y)
    {
        //handle other coordinate-representation
        if((null !== x) && (x.constructor === Array))
        {
            y = x[1];
            x = x[0];
        }

        var distance = Math.sqrt((this.x-x)*(this.x-x) + (this.y-y)*(this.y-y));
        return this.r - distance;
    };
    getCorners()
    {
        var corners = new Array();
        //return empty array
        return corners;
    };
    //get intersection points of this circle and an other shape
    getIntersect(shape)
    {
        //circle and circle: max 2 points as a result of a second-order equation
        //circle and rectangle: max 8 intersections, check line-circle intersections for all rectangle edges

        var res = new Array();
        var d, l, h, ll, rr;

        if(shape instanceof Circle)
        {
            //instead of generally solving the equation pair of two circles, the intersection coordinates are found semi-graphically to add some meaning of the computation (instead of the raw, complex expression coming from the circle equations)
            //The two centers and an intersection point form a triangle which can be split up two right triangles. This two has a common side (h) which is a leg of the right triangles. The other leg of the trangle belonging to this circle is l.
            //source: http://math.stackexchange.com/questions/256100/how-can-i-find-the-points-at-which-two-circles-intersect
            //1. compute distance of the two centers
            d = Math.sqrt((this.x-shape.x)*(this.x-shape.x) + (this.y-shape.y)*(this.y-shape.y));
            //2. get one leg length. If there is no intersections the length will be bigger than r.
            l = (this.r*this.r - shape.r*shape.r + d*d)/(2*d);
            //3. get the other leg length
            h = this.r*this.r - l*l;
            if(0<h)
            {
                h = Math.sqrt(h);
                //4a. two solutions: use vector computations to find the intersections
                res[0] = new Array();
                res[0][0] = (l/d)*(shape.x-this.x) + (h/d)*(shape.y-this.y) + this.x;
                res[0][1] = (l/d)*(shape.y-this.y) - (h/d)*(shape.x-this.x) + this.y;
                res[1] = new Array();
                res[1][0] = (l/d)*(shape.x-this.x) - (h/d)*(shape.y-this.y) + this.x;
                res[1][1] = (l/d)*(shape.y-this.y) + (h/d)*(shape.x-this.x) + this.y;
            }
            else if(0>h)
            {
                //4b. no solution
            }
            else
            {
                //4c. one solution
                res[0] = new Array();
                res[0][0] = (l/d)*(shape.x-this.x) + this.x;
                res[0][1] = (l/d)*(shape.y-this.y) + this.y;
            }
        }
        else if(shape instanceof Rectangle)
        {
            rr = this.r*this.r;

            //check horizontal edges
            ll = (this.y-shape.y1)*(this.y-shape.y1);
            if(ll < rr)
            {
                //two intersections
                h = this.x - Math.sqrt(rr-ll);
                if( (h >= shape.x1) && (h <= shape.x2) )
                {
                    res.push([h, shape.y1]);
                }

                h = this.x + Math.sqrt(rr-ll);
                if( (h >= shape.x1) && (h <= shape.x2) )
                {
                    res.push([h, shape.y1]);
                }
            }
            else if(ll > rr)
            {
                //no intersection
            }
            else
            {
                //one intersection
                if( (this.x >= shape.x1) && (this.x <= shape.x2) )
                {
                    res.push([this.x, shape.y1]);
                }
            }

            ll = (this.y-shape.y2)*(this.y-shape.y2);
            if(ll < rr)
            {
                //two intersections
                h = this.x - Math.sqrt(rr-ll);
                if( (h >= shape.x1) && (h <= shape.x2) )
                {
                    res.push([h, shape.y2]);
                }

                h = this.x + Math.sqrt(rr-ll);
                if( (h >= shape.x1) && (h <= shape.x2) )
                {
                    res.push([h, shape.y2]);
                }
            }
            else if(ll > rr)
            {
                //no intersection
            }
            else
            {
                //one intersection
                if( (this.x >= shape.x1) && (this.x <= shape.x2) )
                {
                    res.push([this.x, shape.y2]);
                }
            }

            //check vertical edges
            ll = (this.x-shape.x1)*(this.x-shape.x1);
            if(ll < rr)
            {
                //two intersections
                h = this.y - Math.sqrt(rr-ll);
                if( (h >= shape.y1) && (h <= shape.y2) )
                {
                    res.push([shape.x1, h]);
                }

                h = this.y + Math.sqrt(rr-ll);
                if( (h >= shape.y1) && (h <= shape.y2) )
                {
                    res.push([shape.x1, h]);
                }
            }
            else if(ll > rr)
            {
                //no intersection
            }
            else
            {
                //one intersection
                if( (this.y >= shape.y1) && (this.y <= shape.y2) )
                {
                    res.push([shape.x1, this.y]);
                }
            }

            ll = (this.x-shape.x2)*(this.x-shape.x2);
            if(ll < rr)
            {
                //two intersections
                h = this.y - Math.sqrt(rr-ll);
                if( (h >= shape.y1) && (h <= shape.y2) )
                {
                    res.push([shape.x2, h]);
                }

                h = this.y + Math.sqrt(rr-ll);
                if( (h >= shape.y1) && (h <= shape.y2) )
                {
                    res.push([shape.x2, h]);
                }
            }
            else if(ll > rr)
            {
                //no intersection
            }
            else
            {
                //one intersection
                if( (this.y >= shape.y1) && (this.y <= shape.y2) )
                {
                    res.push([shape.x2, this.y]);
                }
            }
        }
        else
        {
            //do nothing
        }
        return res;
    }
}

//------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------- CYCLICALLY RUNNING PART -------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------
//The big computations can freeze the page, so they will be performed asynchronously: a timer can run in a separate thread than the
//main page, this will be used to create a separate cyclic "task" in the background. The 'for' loops are decomposed and only one 'for'
//cycle is executed in a timer cycle. Warning: for cycles originally ran after each other cannot be paralellized inside the timer
//loop, because the next depends on the results of the previous one. That's why the step#ready variables are created.
const CYCLETIME = 1;    //1ms is impossible for the browser, practically it means "run as fast as possible"
const sp_inc = 100;     //change speed (cycletime) with this number
var tick = 0;
var task = 0;
var speed = CYCLETIME;   //speed can be slowed down during run
var mainTask = 0; //the ID for the timer will be stored here

//this function is ran cyclically
function mainTaskFunction()
{
    /*
    //example
    //it equals to for(var i=1; i<100; i++)
    if(0==task){if(tick<1){}else if(tick < 100)
    {
        pi += (4*Math.pow(-1, tick+1))/(2*tick-1);
        document.getElementById("test").innerHTML = pi;
    }
    else{task++;tick=0;return;}}
    */

//------------------------------ DATA ------------------------------
    //parsing gym data, see gymData.json
    if(0===task)
    {
        data = JSON.parse(gymData, function(dataName, value)
        {
            var ret;
            if( ("shortName" === dataName) || ("fullName" === dataName) || ("object" === typeof value) )
            {
                ret = value;
            }
            else if("longitude" === dataName)
            {
                //Longitude to km ratio is not the same as latitude to km ratio. The number 1.48 is used to compensate longitude to have the same
                //  ratio as latitude has. The number is calculated based on the original representation of gym locations on the map on pokemongomap.info.
                ret = parseFloat(atob(value))/1.48;
            }
            else
            {
                ret = parseFloat(atob(value));
            }
            return ret;
        } );
        task++;
        return;
    }


//------------------------------ COMPUTATIONS ------------------------------
    //The database contains about 450 gym locations, the algorithm will possibly use a number about 450!.
    //But this number is too big for JavaScript, result of 171! is already shown as infinite.
    //So the analyzed area will be split up to sub-areas containing 50 (parametrizable with subAreaMax) gyms per each.
    //Sub-areas will be generated with overlapping to make the algorithm work also at the border of each sub-area.
    //Ways of genearating sub-areas:
    //x grow circles from specific points (like corners and intersections) of the parent area till each contains 50 gyms and till all gyms belong to at least one sub-area
    //x grow squares
    //- split up the parent area to fixed rectangles

    //Subarea generation:
    //The subareas will be rectangles or circles. The rectangle representing the whole analyzed area (the main rectangle) will be used as the root of the following iteration: this will be the only element in the shape collection when the algorithm starts
    //1. collect points: all corners of all rectangles and all intersections of all shapes (from the shapes collection)
    //2. remove the points which are inside in any subarea (any shape representing a subarea, except the main rectangle)
    //3. order the remaining points according to the rules configured using dirRule
    //4. select the first from the ordered list
    //5. draw a big rectangle or circle around that point (so that point will be the center of the shape)
    //6. count the gyms inside that shape. If there is more inside than a threshold (configurable using subAreaMax), step to 6a, else step to 6b
    //   if the algorithm steps here too much times (configurable using binSearchStepThreshold), stop it and step to 7.
    //6a draw a smaller shape around the point and step to 6.
    //6b draw a bigger shape around the point and step to 6.
    //7. add this new shape to the shapes collection
    //8. check if all gyms are inside at least one shape (except the main rectangle). If no, step to 1. else step to 9.
    //9. the subareas are ready to search the closest 10 gyms
    //The algorithm to make the shape size bigger or smaller in step 6. is like a binary search algorithm: it uses halving/averaging of previous limits.
    //Ordering at step 3. helps to avoid deadlocks in the algorithm.
    //The result of the algorithm is a collection of well-overlapping shapes (as subareas) covering all gyms.

    //generate a lookup table for factorials
    if(1===task){if(tick>subAreaMax){task++;tick=0;return;}else if(0<tick)
    {
        f[tick] = fact(tick);
    }}

    //find the borders of the parent area - initialization
    if(2===task)
    {
        //x=longitude, y=latitude
        minX = data[0].longitude;
        maxX = data[0].longitude;
        minY = data[0].latitude;
        maxY = data[0].latitude;
        task++;
    }

    //find the borders of the parent area
    if(3===task){if(tick>=data.length){task++;tick=0;return;}else if(0<=tick)
    {
        if(minX > data[tick].longitude)
        {
            minX = data[tick].longitude;
        }
        if(maxX < data[tick].longitude)
        {
            maxX = data[tick].longitude;
        }
        if(minY > data[tick].latitude)
        {
            minY = data[tick].latitude;
        }
        if(maxY < data[tick].latitude)
        {
            maxY = data[tick].latitude;
        }
    }}

    //visualize the gyms
    //first create a rectangle showing the area
    if(4===task)
    {
        //because one canvas does not support several layers, the layer behaviour will be imitated using several canvases on top of each other
        //
        //  role on subarea sizing                  role on nearest finding
        //
        //0 main layer containing main frame and points showing the location of each gym (black) (same for both)
        //1 final subareas (black)                  best groups per each subarea
        //2 subarea centers to analyze (red)        actually analyzed subarea
        //3 actual sized shapes (green)             actually analyzed points (gyms)
        if(visualize)
        {
            var canvas = document.getElementById("mainCanvas").getElementsByTagName("canvas");
            //make the area fit into the canvas
            var width = canvas[0].clientWidth;
            var height= canvas[0].clientHeight;
            //compute right scaling ratio
            //first try to let the area width 100% of the canvas width
            //rat * areaWidth = canvasWidth -> rat = canvas/area
            //-1 is needed otherwise the last pixel row/column would be out of the canvas area
            var scale = (width-1)/(maxX-minX);
            if(scale*(maxY-minY) > height)
            {
                scale = (height-1)/(maxY-minY);
            }
            else
            {
                //keep the first scale ratio
            }
            //apply the following settings on all layers
            for(var i=0; i<canvas.length; i++)
            {
                //these properties behave independently of the assigned style, so override the default
                canvas[i].width = width;
                canvas[i].height = height;
                //use the scale on the canvas
                c[i] = canvas[i].getContext("2d");
                //translate with 0.5, because it tries to draw between pixels
                //also translate with height as the first step of converting coordinate system (by default origin is at the top left corner, but the map has the origin at the bottom left)
                c[i].translate(0.5, height-0.5);  //this should be done before scaling. Scaling will not affect this (translating with 0.5 will remain 0.5 after scaling)
                //scale the canvas to use the units of the map (longitude and latitude)
                //minus is needed to convert the coordinate system (by default y grows downwards, but on the gym map y grows upwards)
                c[i].scale(scale, -scale);
                //after scaling the line width should be set properly (it will work as 1px)
                c[i].lineWidth = 1/scale;
                //translate again to compensate minX and minY
                c[i].translate(-minX, -minY);
            }
            //every layer has it's own color
            c[0].strokeStyle = "black";
            c[1].strokeStyle = "black";
            c[2].strokeStyle = "red";
            c[3].strokeStyle = "green";
            //set pointSize which helps to draw "points"
            pointSize = pointSizePx / scale;
            
            task++;
        }
        else
        {
            task += 2;
        }
        
        //the first shape will be the map area rectangle (drawn only on the main canvas)
        subAreas[0] = new Rectangle(minX, minY, maxX, maxY, c[0]);
    }

    //draw all gyms on the main canvas
    if(5===task){if(data.length<=tick){task++;tick=0;return;}else if(0<=tick)
    {
        drawO(data[tick].longitude, data[tick].latitude, c[0]);
    }}

    //init next step
    if(6===task)
    {
        //init point to out of the main rectangle, to be far from the start corner
        if( (0 === dirRule[0]) && (0 === dirRule[1]) )
        {
            point = [maxX + pointSize, maxY + pointSize];
        }
        else if( (0 === dirRule[0]) && (1 === dirRule[1]) )
        {
            point = [maxX + pointSize, minY - pointSize];
        }
        else if( (1 === dirRule[0]) && (0 === dirRule[1]) )
        {
            point = [minX - pointSize, maxY + pointSize];
        }
        else
        {
            point = [minX - pointSize, minY - pointSize];
        }

        //erase the layer (practically only the seen area)
        if(visualize)
        {
            c[2].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
        }
        
        task++;
    }

    //find the next point from corners and intersections
    if(7===task){if(subAreas.length<=tick){task++;tick=0;return;}else if(0<=tick)
    {
        //collect corners of the tick-th shape and also collect all intersections with previous shapes
        var points = subAreas[tick].getCorners();
        var i = -1; //eslint-disable-line no-redeclare
        do
        {
            //skip points which are part of at least one shape
            //but draw all found points
            for(var j=0; j<points.length; j++)
            {
                //draw all found points
                if(visualize)
                {
                    drawX(points[j], c[2]);
                }
                
                //skip points which are out of the main rectangle (being on the edge means that the point is inside the rectangle)
                if(0 > subAreas[0].pointIsInside(points[j]))
                {
                    continue;
                }
                //skip point if the stored one follows the subarea generation direction better than the actual one
                else if(followsDirRule(point, points[j]))
                {
                    continue;
                }
                else
                {
                    //don't skip, continue checking of this point
                }
                //check if the point is inside any shape (being on an edge means it's not inside: all points are on at least one edge/corner of a shape which shouldn't be considered at this check)
                var outside = true;
                for(var k=1; k<subAreas.length; k++)
                {
                    if( (0 < subAreas[k].pointIsInside(points[j])) &&
                        //skip inside check if the actual shape is any of the two which are "parents" of the intersection
                        (k !== tick) && (k !== i) )
                    {
                        outside = false;
                        break;
                    }
                }
                if(outside)
                {
                    //store the point
                    point = points[j];
                    //highlight the remaining points
                    if(visualize)
                    {
                        drawO(points[j], c[2]);
                    }
                }
            }

            //get intersection points
            if(++i<tick)
            {
                points = subAreas[tick].getIntersect(subAreas[i]);
            }
            else
            {
                break;
            }
        } while(true);  //eslint-disable-line no-constant-condition
    }}

    //init binary search algorithm variables
    if(8===task)
    {
        if(visualize)
        {
            //erase the layer (practically only the seen area)
            c[2].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
        
            //highlight point (center of the shape to be drawn)
            drawX(point, c[1]);
        }
        
        lowerSize = 0;
        if(maxX-minX > maxY-minY)
        {
            higherSize = 2*(maxX-minX);
        }
        else
        {
            higherSize = 2*(maxY-minY);
        }
        size = higherSize;

        task++;
    }

    //use binary search-like algorithm to find the right size for each shape
    if(9===task)
    {
        var subArea;
        
        //erase the layer (practically only the seen area)
        if(visualize)
        {
            c[3].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
        }
        
        //create (and draw) a subarea shape object around the actual point with the actual size
        switch(subAreaType)
        {
            case 0:
                subArea = new Rectangle(point[0]-size/2,
                                    point[1]-size/2,
                                    point[0]+size/2,
                                    point[1]+size/2,
                                    c[3]);
                break;
            case 1:
                subArea = new Circle(point[0], point[1], size/2, c[3]);
                break;
            case 2:
                var rat = (maxY-minY)/(maxX-minX);
                subArea = new Rectangle(point[0]-size/2,
                                    point[1]-rat*(size/2),
                                    point[0]+size/2,
                                    point[1]+rat*(size/2),
                                    c[3]);
                break;
        }

        //count the gyms inside the subarea
        var count = 0;
        for(var i=0; i<data.length; i++)    //eslint-disable-line no-redeclare
        {
            //gym on edge doesn't count. Make subarea bigger to be the gym really inside it
            //x=longitude, y=latitude
            if(0 < subArea.pointIsInside(data[i].longitude, data[i].latitude))
            {
                count++;
            }
        }

        //check for next steps
        if(tick >= binSearchStepThreshold)
        {
            //store subarea
            subAreas.push(subArea);
            
            if(visualize)
            {
                //draw it to an other layer to keep it
                subArea.draw(c[1]);
                //clear layer
                c[3].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
            }
            
            task++;
            tick=0;
            return;
        }
        else if(subAreaMax >= count)    //make the subarea bigger even if the the count condition is met (count == subAreaMax) to make the subarea as large as possible --> maybe fewer subareas will be enough to cover the main area
        {
            lowerSize = size;
        }
        else //subAreaMax < count
        {
            higherSize = size;
        }
        size = (higherSize + lowerSize)/2;
    }

    //check if the subareas cover all gyms
    if(10===task){if(data.length<=tick){task++;tick=0;return;}else if(0<=tick)
    {
        if(visualize)
        {
            drawX(data[tick].longitude, data[tick].latitude, c[3]);
        }
        
        var inSubArea = false;
        //exclude the main rectangle
        for(var i=1; i<subAreas.length; i++)    //eslint-disable-line no-redeclare
        {
            //gym on edge counts to avoid adding more subareas than really needed
            //x=longitude, y=latitude
            if(0 <= subAreas[i].pointIsInside(data[tick].longitude, data[tick].latitude))
            {
                inSubArea = true;
                subAreas[i].gyms.push(data[tick]);
                break;
            }
        }

        if(!inSubArea)
        {
            //clear layer
            if(visualize)
            {
                c[3].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
            }
            
            //empty gym storage
            for(var i=1; i<subAreas.length; i++)    //eslint-disable-line no-redeclare
            {
                subAreas[i].gyms = [];
            }
            
            task = 6;
            tick = 0;
            return;
        }
    }}

    //go through all subareas and search for the closest gyms in each
    if(11===task)
    {
        //clear layer
        if(visualize)
        {
            c[3].clearRect(minX-pointSize, minY-pointSize, maxX-minX+2*pointSize, maxY-minY+2*pointSize);
        }

        task++;
        return;
    }

    //TODO:
    //1. generate combinations
    //2. calculate a number usable to compare the combinations
    //3. compare the numbers and select the best one(s)
    //do these steps only in one cycle, tick will be the combinadic number (the ranker)

//------------------------------ STATISTICS ------------------------------


    if(12===task)
    {
        stop;   //eslint-disable-line no-unused-expressions
    }
    document.getElementById("cycle").innerHTML = tick;
    document.getElementById("taskID").innerHTML = task;
    tick++;
}

//This trick enables to call a function without "()". Then it's easy to write commands in the console
Object.defineProperty(global, "start",   { get: function() { mainTask = setInterval(mainTaskFunction, speed);   return mainTask; } } );
Object.defineProperty(global, "stop",    { get: function() { clearInterval(mainTask);                           return mainTask; } } );
//TODO: reset/reinit all globals
Object.defineProperty(global, "reset",   { get: function() { stop; tick=0; task=0;                              return mainTask; } } ); //eslint-disable-line no-unused-expressions
Object.defineProperty(global, "restart", { get: function() { reset; start;                                      return mainTask; } } ); //eslint-disable-line no-unused-expressions, no-undef
//those commands control the speed of the algorithm (via the timer cycletime)
Object.defineProperty(global, "slower",  { get: function() { speed += sp_inc; stop; start;                      return speed; } } );    //eslint-disable-line no-unused-expressions, no-undef
Object.defineProperty(global, "faster",  { get: function() { if((speed-=sp_inc)<CYCLETIME){speed=CYCLETIME;} stop; start; return speed; } } );   //eslint-disable-line no-unused-expressions, no-undef


//------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------- IT RUNS AFTER PAGE LOAD ------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------
$(document).ready( function () {
//------------------------------ VISUALIZATION ------------------------------
var table = document.getElementById("mainTable");
var header = document.createElement("thead");
table.appendChild(header);
var firstRow = document.createElement("tr");
header.appendChild(firstRow);
var emptyCell = document.createElement("td");
firstRow.appendChild(emptyCell);    //empty cell on the corner

document.getElementById("numOfGyms").innerHTML = numOfGyms;

restart;    //eslint-disable-line no-unused-expressions
} );    //end of ready event handler

</script>

<style>
table {
    border: 1px solid black;
    border-spacing: 0; /* Removes the cell spacing via CSS */
    border-collapse: collapse;  /* Optional - if you don't want to have double border where cells touch */
}
td {
    border: 1px solid black;
    /*padding: 3px;*/
    white-space: nowrap;
    /*font-size: 12px;*/
    background-color: white;
}
.DTFC_LeftBodyLiner {
    border-right: 1px solid black;
    overflow-x: hidden;
}
canvas {
    position: absolute;
    border: black 1px solid;
    width: 100%;
    height: 800px;
}
</style>
</head>
<body>

Find <span id="numOfGyms"></span> gyms which are the closest to each other<br><br>
Active task: <span id="taskID"></span><br>
Cycle counter: <span id="cycle"></span><br><br>


<table id="mainTable"></table>
<div id="mainCanvas">
    <canvas style="'z-index: 1"></canvas>
    <canvas style="'z-index: 2"></canvas>
    <canvas style="'z-index: 3"></canvas>
    <canvas style="'z-index: 4"></canvas>
</div>
</body>
</html>
